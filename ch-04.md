# Attributes and memory

Let us create a class, instantiate it and populate it with two attributes.

    class A(object):
        pass
        
    a = A()
    a.x = 12
    a.y = 13
    
    print('a.x = %d; a.y = %d' % (a.x, a.y))
    >>> a.x = 12; a.y = 13

It will be interesting to check what are the attributes of this instance `a` -

    print(dir(a))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',
        '__sizeof__', '__slots__', '__str__', '__subclasshook__', '__weakref__', 'x', 'y']

In this example, we have created the attributes `x` and `y` on-the-fly. Python provides no restrictions over what can be created and also at what point an attribute has to be created. These attributes that are associated on-the-fly to an instance are stored in `__dict__`

    print(a.__dict__)
    >>> {'x': 12, 'y': 13}
    
It is possible to attach a function to the instance but it must be noted that there would be no binding (using `self`) of the function to the instance object. Say, we write

    def print_xy(self):
        print(self.x)
        print(self.y)
        return
        
    a.print_xy = print_xy
    
    print(a.__dict__)
    >>> {'x': 12, 'y': 13, 'print_xy': <function print_x at 0x00665A08>}
    
While we have attached the function, we have not bound it to the instance object.

    a.print_xy()
    >>> Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        TypeError: print_x() missing 1 required positional argument: 'self'

The following works, as the instance `a` (as argument to the function call) is explicitly bound to `self`.

    a.print_xy(a)
    >>> 12
        13

This is no different from calling `print_xy(a)` which was already there in the default namespace instead of copying it to namespace of `a` and calling it as `a.print_xy(a)`. It is possible to redefine `print_xy` and thus have a new definition of `print_xy` in the default namespace while the old definition is still preserved inside `a`. There can be a usecase where attribute values and function definitions change dynamically and the user is interested in storing the history.

    A = type('A', (object,), {})
