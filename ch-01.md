## Classes from `type`

We start from a blank class definition that Python Supports

    class A(object):
        pass
       
       
This class does nothing. If you try to instantiate the class, it inherits all the attributes from the default Python *object*. A quick way to check the attributes of this class is to use the `dir` function.

    print(dir(A))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
    print(A)
    >>> <class '__main__.A'>

We also see the output of `__repr__` -- a string representation of the class.

There is an alternate way of declaring the class. We'll use the `type` function.

    B = type('B', (object,), {})
    
At this point, `B` is identical to `A`. Let's have a look. 

    print(dir(B))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
    print(B)
    >>> <class '__main__.B'>
 
It is necessary to undertand the arguments that the `type` function takes. In fact, there are two separate implementations of `type`. This is what the official documentation of Python 3.6 says --

> `class type(object)`   
> `class type(name, bases, dict)`   
> With one argument, return the type of an object. The return value is a type object and generally the same object as returned by `object.__class__`.

The first argument is the name. This is the name that is displayed when `print(B)` is executed. It may or may not be same as the object variable B. The second one is a tuple of base classes. In fact, we need not inherit the `object` base class explicitely in Python 3. An empty tuple, `()`, would suffice. The call `B = type('B', (object,), {})` is identical to `B = type('B', (), {})`. So are the class declarations `class A(object):` and `class A():`.

## Attributes of a class

The `dir` function lists the objects that are objects. Classes are objects, too. The attributes of are what are inherited from the base classes and anything else that has been declared inside the class.

    class A(object):
    
        name = 'Class A'
        
        def whomai():
            print('I am a function')
            return
                        
The class declaration is completely useless from a practical point of view. It is useful as a demonstator. You get two new objects -- the variable `name` and the function `whoami`. These are listed in the scope by `dir`.

    print(dir(A))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'whoami']
        
It is possible to write these variables and methods outside the scope of the class definition and add them as an attribute to the class.

    B = type('B', (object,), {})
    
    name = 'Class B'
        
    def whoami():
        print('I am a function')
        return    
        
    setattr(B, 'name', name)
    setattr(B, 'whoami', whoami)
    
    print(dir(B))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'whoami']

Note that this approach sets us up for creating class definitions from scratch. This involves two steps. First, declare the class using the `type` function and second, assimilate all attributes into the class. Other than `setattr`, there are three other functions that will help us in playing with the attributes of an object.

The retrival function to `setattr` is `getattr`. It returns the object (variable, method) inside another object. For example, check the following code -- 

    whoami_extracted = getattr(B, 'whoami')
    
    whoami_extracted()
    >>> I am a function
    
    B.whoami()
    >>> I am a function

In essence, `whoami_extracted = getattr(B, 'whoami')` is equivalent to `whoami_extracted = B.whoami`. 

There is also a function called `delattr` that removes an attribute from an object. Here is an example.

    delattr(B, 'whoami')
    
    print(dir(B))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name']

Python has a predicate function called `hasattr` to check if an attribute is present in an object. For example, after we have deleted the `whoami` attribute from `B`, we could query `B`.

    print(hasattr(B, 'whoami'))
    >>> False
    
    print(hasattr(B, 'name'))
    >>> True

-
