## Classes from `type`

We start from a blank class definition that Python Supports

    class A(object):
        pass
       
       
This class does nothing. If you try to instantiate the class, it inherits all the attributes from the default Python *object*. A quick way to check the attributes of this class is to use the `dir` function.

    print(dir(A))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
    print(A)
    >>> <class '__main__.A'>

We also see the output of `__repr__` -- a string representation of the class.

There is an alternate way of declaring the class. We'll use the `type` function.

    B = type('B', (object,), {})
    
At this point, `B` is identical to `A`. Let's have a look. 

    print(dir(B))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
    print(B)
    >>> <class '__main__.B'>
 
It is necessary to undertand the arguments that the `type` function takes. In fact, there are two separate implementations of `type`. This is what the official documentation of Python 3.6 says --

> `class type(object)`   
> `class type(name, bases, dict)`   
> With one argument, return the type of an object. The return value is a type object and generally the same object as returned by `object.__class__`.

The first argument is the name. This is the name that is displayed when `print(B)` is executed. It may or may not be same as the object variable B. The second one is a tuple of base classes. In fact, we need not inherit the `object` base class explicitely in Python 3. An empty tuple, `()`, would suffice. The call `B = type('B', (object,), {})` is identical to `B = type('B', (), {})`. So are the class declarations `class A(object):` and `class A():`.

## Attributes of a class

The `dir` function lists the objects that are objects. Classes are objects, too. The attributes of are what are inherited from the base classes and anything else that has been declared inside the class.

    class A(object):
    
        name = 'Class A'
        
        def whomai():
            print(name)
            return
                        
The class declaration is completely useless from a practical point of view. You get two new objects -- the variable `name` and the function `whoami`. These are listed in the scope by `dir`.

    print(dir(A))
    >>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
        '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', 
        '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', 
        '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'whoami']
        
-
